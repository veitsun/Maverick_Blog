# 包管理工具 apt

sudo apt install ./package.deb    # 安装 deb 包

sudo apt remove package_name # 移除已安装的软件

sudo apt update && sudo apt upgrade # 更新系统软件

# 统计代码行数

统计一个目录中（包含子目录） 中的代码行数。

```linux
find . | grep '\.c$\|\.h$' | xargs wc -l
```

`find . ` 能够列出当前目录下的所有文件，

`grep` 实现了输入的过滤，这里的grep + 参数 可以匹配以 .c 和 .h 结束的文件（正则表达式是处理字符串非常强大的工具）

`wc -l` -l 选项能够计算代码的行数。

`xargs` 能够将标准输入转换为参数， 传递给第一个参数所指定的程序

# 统计磁盘的使用情况

统计 /usr/share 目录下各个目录所占用的磁盘空间

```linux
du -sc /usr/share/* | sort -nr
```

`du` 是磁盘空间分析工具，  `du -sc`将目录的大小顺次输出到标准输出,继而通过管道传送给`sort`. `sort`是数据排序工具, 其中的选项`-n`表示按照数值进行排序, 而`-r`则表示从大到小输出. `sort`可以将这些参数连写在一起.

然而我们发现, `/usr/share`中的目录过多, 无法在一个屏幕内显示. 此时, 我们可以再使用一个命令: `more`或`less`.

```
du -sc /usr/share/* | sort -nr | more
```

此时将会看到输出的前几行结果. `more`工具使用空格翻页, 并可以用`q`键在中途退出. `less`工具则更为强大, 不仅可以向下翻页, 还可以向上翻页, 同样使用`q`键退出.

# 使用重定向

有时我们希望将程序的输出信息保存到文件中, 方便以后查看. 例如你编译了一个程序`myprog`, 你可以使用以下命令对`myprog`进行反汇编, 并将反汇编的结果保存到`output`文件中:

```
objdump -d myprog > output
```

`>`是标准输出重定向符号, 可以将前一命令的输出重定向到文件`output`中. 这样, 你就可以使用文本编辑工具查看`output`了.

但你会发现, 使用了输出重定向之后, 屏幕上就不会显示`myprog`输出的任何信息. 如果你希望输出到文件的同时也输出到屏幕上, 你可以使用`tee`命令:

```
objdump -d myprog | tee output
```

使用输出重定向还能很方便地实现一些常用的功能, 例如

```
> empty                  # 创建一个名为empty的空文件
cat old_file > new_file  # 将文件old_file复制一份, 新文件名为new_file
```

如果`myprog`需要从键盘上读入大量数据(例如一个图的拓扑结构), 当你需要反复对`myprog`进行测试的时候, 你需要多次键入大量相同的数据. 为了避免这种无意义的重复键入, 你可以使用以下命令:

```
./myprog < data
```

`<`是标准输入重定向符号, 可以将前一命令的输入重定向到文件`data`中. 这样, 你只需要将`myprog`读入的数据一次性输入到文件`data`中, `myprog`就会从文件`data`中读入数据, 节省了大量的时间.

下面给出了一个综合使用重定向的例子:

```
time ./myprog < data | tee output
```

这个命令在运行`myprog`的同时, 指定其从文件`data`中读入数据, 并将其输出信息打印到屏幕和文件`output`中. `time`工具记录了这一过程所消耗的时间, 最后你会在屏幕上看到`myprog`运行所需要的时间. 如果你只关心`myprog`的运行时间, 你可以使用以下命令将`myprog`的输出过滤掉:

```
time ./myprog < data > /dev/null
```

`/dev/null`是一个特殊的文件, 任何试图输出到它的信息都会被丢弃, 你能想到这是怎么实现的吗? 总之, 上面的命令将`myprog`的输出过滤掉, 保留了`time`的计时结果, 方便又整洁.
