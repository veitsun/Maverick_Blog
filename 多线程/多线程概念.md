单核时代：多个线程是并发的

多核时代：多个线程可以是并行的

> 例如现在常见的**4核4线程**可以并行4个线程；**4核8线程**则使用了超线程技术，把一个物理核模拟为2个逻辑核心，可以并行8个线程。

**管理线程的生命周期**

detach 将此线程与调用它的线程分离，被分离的线程成为后台线程，独立于主线程

join 用于等待线程完成，主线程会阻塞，直到被调用的线程结束。

> 无论在何种情形，一定要在`thread`销毁前，调用`t.join`或者`t.detach`，来决定线程以何种方式运行。

> 而使用detach方式则不会对当前代码造成影响，当前代码继续向下执行，创建的新线程同时并发执行，这时候需要特别注意：**创建的新线程对当前作用域的变量的使用**，创建新线程的作用域结束后，有可能线程仍然在执行，这时局部变量随着作用域的完成都已销毁，如果线程继续使用局部变量的**引用或者指针**，会出现意想不到的错误，并且这种错误很难排查。例如：
> 
> 所以在以detach的方式执行线程时，要将线程访问的局部数据复制到线程的空间（使用值传递），一定要确保线程没有使用局部变量的引用或者指针，除非你能肯定该线程会在局部作用域结束前执行结束。

**线程管理**

每个应用程序至少有一个进程，而每个进程有一个主线程，除了主线程外，在一个进程中还可以创建多个线程。每个线程都需要一个入口函数，入口函数返回退出，主线程就是以main函数作为入口函数的线程

> 在C++ 11的线程库中，将线程的管理放在了类`std::thread`中，使用`std::thread`可以创建、启动一个线程，并可以将线程挂起、结束等操作。

**一些函数**

std::ref  

为了确保 `func` 函数能够修改主线程中的 `_tagNode` 对象，你需要传递对象的引用。可以使用 `std::ref` 来传递引用。
